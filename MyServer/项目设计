前端 + backend1设计
1. 任务创建
   前端：任务名称、模糊器、测试节点数量、单个节点测试时间、可执行文件名、固件文件。
   backend1: 任务名称、模糊器、测试节点数量、剩余任务数目、完成度、单个节点测试时间、可执行文件名、主节点的任务存储路径、任务创建时间、漏洞数目 => 存入数据库。
   backend2: 依据主节点的固件存储路径将固件 => 子节点， 任务名称、模糊器、单个节点测试时间、可执行文件名 => 子节点。
   子节点: 种子、漏洞用例+漏洞信息、日志信息（整个日志信息）=> backend2。
   backend2: 子节点传上来的日志信息就存在对应的任务目录下，前端需要查看日志信息的时候就去jobpath/info目录下读取。       
# 默认是上传已经编译好的文件,在backend1存储的时候，固件文件名采用任务名
# 当完成度＝所需测试节点数量的时候就代表已经完成了
# 在节点数量不足的情况下，当日志信息上传时，当前的日志信息不要覆盖了之前的日志信息。解决方法，backend2在分配给子节点任务的时候，会同时传递剩余任务数目，然后子节点上传的日志信息可以命名为node_surplusnum，这样就可以避免同一个任务由同一个子节点多次执行时出现的日志信息覆盖问题了。
# 子节点每完成一个任务都会向主节点发送一个任务完成请求，由backend2来将completenum++,completenum可以代表完成度，任务完成后backend2会将nodes表中的jobid设置为0,表示空闲，集群节点资源管理会将此信息显示出来，然后管理员可以依据这个可用资源数来分配任务。
# 当completenum+1==botnum时，在更新completenum之前需要对已发现的漏洞进行去重操作。

3. 任务列表（正在运行/已完成）
   正在运行：以表格的形式显示，任务ID、任务名、模糊器、节点数、运行时间（每个节点的fuzz）、任务创建时间、已发现漏洞数、任务完成度、运行日志信息链接
   已完成：  以表格的形式显示，任务ID、任务名、模糊器、节点数、运行时间、任务创建时间、总漏洞数（可查看漏洞信息）、运行日志信息链接
　　给出任务名，可以搜索指定的任务
    如果表格内容过多，可以整一个详细信息链接，只有点击详细信息才能看到完整的信息（以纵向列表显示）
　　点击运行日志信息，会出现一个列表，显示所有执行过该任务的节点所产生的日志信息（现在先直接显示，不精简）。
　　节点信息列表：　日志名　日志信息详情（直接通过表格显示，表格大小框定，可以有下拉条）
　　点击总漏洞数，可以显示漏洞列表的功能，但只限定在该任务，并且已修复和未修复的漏洞都会出现，未修复在前，已修复在后

4. 漏洞列表（未修复/已修复） 　#　只存放任务已经完成后所发现的漏洞
　　id  漏洞名　任务名　发现时间　是否已修复　详细漏洞信息　（由backend2查询漏洞信息文件来显示）
　　点击漏洞信息链接会转入制定的页面显示漏洞信息

2. 集群节点资源管理
   以表格的形式显示，节点名称、ip地址、内存大小、核心数目、是否空闲、正在运行的任务ID、还有多久能结束，一个链接可以查看运行日志信息
# 查看当前正在运行的日志信息，如果一个节点多次取同一个任务，那么取最新的那个运行日志
# 某个节点还有多久结束当前任务，可以通过设置取任务的时间点，然后通过时间差来判断

5. 漏洞复现 做成两种方式：# 1.上传漏洞用例(利用外部已经发现的漏洞用例做检测)，对已经存在的软件进行检验。
                         2.另一种是上传固件（已经存在软件的新的版本），使用已发现的漏洞用例对其进行检测。漏洞修复验证。
#先做2
backend2的任务分配中设置一个flag，交替分配任务给子节点，上一次分配fuzz任务，这次就分配reproduce任务。
任务的创建与fuzz类似，将指定的漏洞用例与固件存放在一起（通过jobname来获取jobpath，再从crash目录下依据crashname来获取指定的漏洞用例）。backend2会对日志信息进行检验，如果漏洞信息还是存在，那么将漏洞信息显示，如果漏洞已经修复了，就在crashes中将对应的漏洞的isfix标记为1,表示已经修复。

改进：
1. 节点突然死亡，那么任务就永远不会结束？
2. 信息同步机制太原始了。
3. 漏洞复现之上传测试用例。
4. 当节点资源不足且都在运行fuzz时，漏洞复现需要有等很久。
5. 版本间漏洞的重定位。

任务规划：
1. 完成前三个功能的打通，从fronted->backend1->backend2->nodes
2. 集群节点资源管理界面实现
3. 功能修改规划
4. 漏洞复现功能实现

前端问题：
1. reproduce页面中任务创建成功跳转后无法实时显示最新信息？
2. 漏洞信息与日志信息显示的时候，无法换行的问题？
3. 任务创建的时候需要添加条件限制
4. 换页符号箭头呈现白色


需要添加的东西：
1. backend1中的nodes.py中，删除死亡节点后再显示


－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－－
backend2 + clientnode 

client:
  1. 如果没有取到任务，就每隔10秒向backend2发送任务请求。如果任务取到了，就按照固定的时间间隔同步种子和运行日志。
     种子同步的时候，会将本地的所有种子全部同步过去，同时下载主节点中的所有种子文件，参考disfuzz，30秒同步一次。
     日志信息每隔30秒同步一次。
  2. 一台机器有多少资源，就创建多少个运行节点，nodes表中的机器信息用场不大了

backend2:
  1. 






存在的问题：
1. 漏洞如何去重？
　 在哪里进行去重？　可以当任务运行完毕后在backend2中进行去重，也可以将去重任务交给子节点。
2. 如何判断节点死亡（未运行任务时死亡，运行任务到一半时死亡）？（在节点资源管理中需要用到）　当前端查看节点资源管理的时候，会对nodes表进行操作，先删除死亡节点，在进行节点资源显示。在进行信息同步的时候，backend2会更新nodes的last_modify_time，或者取任务的时候也会更新，当超过某个时间阈值（2h）而未更新时，就可以判定该节点已经死亡，将其从nodes表中删除。
3. 种子去重？
4. 同一个节点执行多次时，后一次的漏洞信息和种子信息会覆盖前一次。需要改进。
5. afl和honggfuzz漏洞信息的显示。



任务规划：
1. reproduce实现  //success
2. 双节点测试　//success
3. afl、honggfuzz  
4. 一个节点多次取任务




"""
libfuzz fuzz:
info_path = info + nodename + "_" + surplusum + ".log"
      print(info_path)
      cmd = target + " " + input
      with open(info_path, "wb") as out:   # Todo use all the time
          pro = subprocess.Popen(cmd, stderr=out)
      time.sleep(int(max_time))
      p = psutil.Process(pro.pid)
      p.terminate()
      for proc in psutil.process_iter():  # 通过进程名的方式来kill进程
          if proc.name() == execname:  # 不同的模糊测试实例该名字不一样
              proc.terminate()
              print("libfuzzer process end successfully!")
              break
      lsdir = os.listdir("./")
      for i in lsdir:  # 将漏洞文件移入指定的目录中去
          if "crash-" in i:
              shutil.move("./" + i, output)
"""


crash-2885f8ae7984cd88da46c6fee0413fee1a9f7b24
crash-2885f8ae7984cd88da46c6fee0413fee1a9f7b24


/home/ybxm/AFL/afl-2.52b/afl-g++ -g handshake-fuzzer.cc  openssl-1.0.1f/libssl.a openssl-1.0.1f/libcrypto.a -std=c++17 -Iopenssl-1.0.1f/include/ -lstdc++fs -ldl -lstdc++ -o afl-handshake






　　
